
#include <iostream>
#include <vector>
#include <queue>

class Node
{
public:
	int Number;
	std::vector<int> Nodes;

	int DistanceToThisElement = 0;

	Node(int number, std::vector<int> nodes) : Number(number), Nodes(nodes) {}

	void setDistanceToThisElement(int distance) { DistanceToThisElement = distance; }

	friend bool operator<(const Node& n1, const Node& n2);

	bool operator==(const Node& n)
	{
		if (Number == n.Number)
			return true;
		return false;
	}

	friend std::ostream& operator<<(std::ostream& stream, Node& nod);
};

std::ostream& operator<<(std::ostream& str, const Node& nod)
{
	str << "Number: " << nod.Number;
	return str;
}

bool operator<(const Node& n1, const Node& n2)
{
	if (n1.DistanceToThisElement > n2.DistanceToThisElement)
		return true;
	return false;
}

template <class T>
void PrinPriorityQueue(std::priority_queue<T> q)
{
	while (!q.empty()) 
	{
		std::cout << q.top() << std::endl;
		q.pop();
	}
}

void FindOstov(int index, std::vector<Node> nodes)
{
	std::priority_queue<Node> NodesQueue;
	
	// Выделяем размер вектора для возможности поместить туда все элементы вектора нод.
	// Так мы решим проблему с долгим добавлением.
	int* PassedNodesArray = new int[nodes.size()];
	for (int i = 0; i < nodes.size(); i++)
	{
		PassedNodesArray[i] = 0;
	}

	int* WasPrintedNode = new int[nodes.size()];
	for (int i = 0; i < nodes.size(); i++)
	{
		WasPrintedNode[i] = 0;
	}

	NodesQueue.push(nodes[index]);
	PassedNodesArray[index] = 1;

	while (!NodesQueue.empty())
	{
		for (int i = 0; i < nodes.size(); i++)
		{
			if (PassedNodesArray[i] == 1 && nodes[i].DistanceToThisElement > NodesQueue.top().Nodes[i] && NodesQueue.top().Nodes[i] > 0)
				NodesQueue.push(nodes[i]);
			
			nodes[i].setDistanceToThisElement(NodesQueue.top().Nodes[i]);

			if (WasPrintedNode[NodesQueue.top().Number] == 0)
				std::cout << nodes[i].DistanceToThisElement << " ";

			if (PassedNodesArray[i] == 0 && nodes[i].DistanceToThisElement > 0)
			{
				NodesQueue.push(nodes[i]);
				PassedNodesArray[i] = 1;
			}
			
		}

		if (WasPrintedNode[NodesQueue.top().Number] == 0)
			std::cout << std::endl;

		//if (WasPrintedNode[NodesQueue.top().Number] == 0)
		//{
		//	std::cout << NodesQueue.top().Number << std::endl;
		//}

		WasPrintedNode[NodesQueue.top().Number] = 1;

		NodesQueue.pop();		
	}

	delete[] PassedNodesArray;
	delete[] WasPrintedNode;
}

int main()
{
	std::vector<std::vector<int>> Matrix = {
	{ 0, 5, 3, 6, 8, 9, 7, 8, 1, 7, 0, 0, 4, 8 },
	{ 5, 0, 0, 3, 6, 9, 6, 5, 0, 8, 0, 0, 5, 6 },
	{ 3, 0, 0, 2, 8, 1, 3, 0, 8, 8, 5, 5, 8, 4 },
	{ 6, 3, 2, 0, 4, 6, 6, 4, 6, 8, 8, 6, 9, 4 },
	{ 8, 6, 8, 4, 0, 2, 8, 0, 9, 0, 8, 2, 0, 5 },
	{ 9, 9, 1, 6, 2, 0, 8, 5, 5, 9, 8, 8, 9, 8 },
	{ 7, 6, 3, 6, 8, 8, 0, 3, 6, 6, 8, 1, 5, 6 },
	{ 8, 5, 0, 4, 0, 5, 3, 0, 7, 1, 4, 7, 8, 5 },
	{ 1, 0, 8, 6, 9, 5, 6, 7, 0, 1, 2, 5, 2, 2 },
	{ 7, 8, 8, 8, 0, 9, 6, 1, 1, 0, 6, 2, 4, 8 },
	{ 0, 0, 5, 8, 8, 8, 8, 4, 2, 6, 0, 8, 4, 3 },
	{ 0, 0, 5, 6, 2, 8, 1, 7, 5, 2, 8, 0, 5, 5 },
	{ 4, 5, 8, 9, 0, 9, 5, 8, 2, 4, 4, 5, 0, 3 },
	{ 8, 6, 4, 4, 5, 8, 6, 5, 2, 8, 3, 5, 3, 0 },
	};

	std::vector<Node> Nodes;
	for (int i = 0; i < Matrix.size(); i++)
		Nodes.push_back(Node(i, Matrix[i]));

	std::vector<std::vector<int>> Matrix1 = {
		{0, 6, 1, 5, 0, 0},
		{6, 0, 5, 0, 3, 0},
		{1, 5, 0, 5, 6, 4},
		{5, 0, 5, 0, 0, 2},
		{0, 3, 6, 0, 0, 0},
		{0, 0, 4, 2, 0, 0}
	};

	std::vector<Node> Nodes1;
	for (int i = 0; i < Matrix1.size(); i++)
		Nodes1.push_back(Node(i, Matrix1[i]));

	FindOstov(0, Nodes1);
}